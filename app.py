import streamlit as st
import pandas as pd
from googleapiclient.discovery import build
from datetime import datetime, timedelta
import requests
from PIL import Image
from io import BytesIO
import re

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="YouTube Explorer Pro",
    page_icon="üöÄ",
    layout="wide"
)

# Configura√ß√£o da API
API_KEY = "AIzaSyAUYjDb23f1tD2XMR1wWDtupNpK427WHyY"
youtube = build('youtube', 'v3', developerKey=API_KEY)

# CSS customizado
st.markdown("""
<style>
.main-header {
    font-size: 2.5rem;
    color: #FF0000;
    text-align: center;
    margin-bottom: 1rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

.tab-header {
    font-size: 1.5rem;
    color: #333;
    text-align: center;
    margin-bottom: 1rem;
}

.video-card {
    border: 1px solid #ddd;
    border-radius: 12px;
    padding: 15px;
    margin: 15px 0;
    background: linear-gradient(135deg, #f9f9f9 0%, #ffffff 100%);
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    transition: transform 0.2s;
}

.video-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.video-title {
    font-size: 1.3rem;
    font-weight: bold;
    color: #333;
    margin-bottom: 8px;
    line-height: 1.3;
}

.channel-info {
    color: #666;
    font-size: 1rem;
    margin-bottom: 5px;
}

.video-stats {
    color: #0066cc;
    font-size: 0.9rem;
    font-weight: 600;
}

.trending-badge {
    background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: bold;
    margin-left: 10px;
}

.new-channel-badge {
    background: linear-gradient(45deg, #A8E6CF, #88D8A3);
    color: #2d5a3d;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: bold;
    margin-left: 5px;
}

.metric-container {
    background: #f0f2f6;
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    margin: 10px 0;
}

.trending-section {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 20px;
}
</style>
""", unsafe_allow_html=True)

def format_number(num):
    """Formatar n√∫meros grandes"""
    if num >= 1000000000:
        return f"{num/1000000000:.1f}B"
    elif num >= 1000000:
        return f"{num/1000000:.1f}M"
    elif num >= 1000:
        return f"{num/1000:.1f}K"
    return str(num)

def parse_duration(duration):
    """Converter dura√ß√£o ISO 8601 para segundos"""
    match = re.match(r'PT(\d+H)?(\d+M)?(\d+S)?', duration)
    if not match:
        return 0
    
    hours = int(match.group(1)[:-1]) if match.group(1) else 0
    minutes = int(match.group(2)[:-1]) if match.group(2) else 0
    seconds = int(match.group(3)[:-1]) if match.group(3) else 0
    
    return hours * 3600 + minutes * 60 + seconds

def format_duration(seconds):
    """Formatar dura√ß√£o em formato leg√≠vel"""
    if seconds >= 3600:
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        return f"{hours}h {minutes}m"
    elif seconds >= 60:
        minutes = seconds // 60
        secs = seconds % 60
        return f"{minutes}m {secs}s"
    else:
        return f"{seconds}s"

def get_channel_age_days(channel_id):
    """Calcular idade do canal em dias"""
    try:
        request = youtube.channels().list(part='snippet', id=channel_id)
        response = request.execute()
        if response['items']:
            published_at = response['items'][0]['snippet']['publishedAt']
            created_date = datetime.fromisoformat(published_at.replace('Z', '+00:00')).replace(tzinfo=None)
            return (datetime.now() - created_date).days
    except:
        pass
    return 9999

def search_videos(query, max_results=50, published_after=None, order='relevance'):
    """Buscar v√≠deos no YouTube"""
    try:
        search_params = {
            'part': 'snippet',
            'q': query,
            'type': 'video',
            'maxResults': max_results,
            'order': order,
            'regionCode': 'BR',
            'relevanceLanguage': 'pt'
        }
        
        if published_after:
            search_params['publishedAfter'] = published_after.isoformat() + 'Z'
        
        request = youtube.search().list(**search_params)
        response = request.execute()
        
        return process_video_results(response)
    
    except Exception as e:
        st.error(f"Erro na busca: {str(e)}")
        return []

def get_trending_videos(min_views=1000, days_back=7, max_results=50):
    """Buscar v√≠deos em tend√™ncia sem query espec√≠fica"""
    try:
        # Usar termos gen√©ricos populares para capturar conte√∫do em alta
        trending_queries = [
            "", # Query vazia para pegar trending geral
            "viral", 
            "2025",
            "novo",
            "hoje"
        ]
        
        all_videos = []
        published_after = datetime.now() - timedelta(days=days_back)
        
        for query in trending_queries[:2]:  # Usar apenas 2 queries para n√£o esgotar quota
            search_params = {
                'part': 'snippet',
                'type': 'video',
                'maxResults': max_results // 2,
                'order': 'date',  # Mais recentes primeiro
                'publishedAfter': published_after.isoformat() + 'Z',
                'regionCode': 'BR',
                'relevanceLanguage': 'pt'
            }
            
            if query:  # Se n√£o for query vazia
                search_params['q'] = query
            
            request = youtube.search().list(**search_params)
            response = request.execute()
            
            videos = process_video_results(response)
            
            # Filtrar por views m√≠nimas
            filtered_videos = [v for v in videos if v['views'] >= min_views]
            all_videos.extend(filtered_videos)
        
        # Remover duplicatas por ID
        unique_videos = {}
        for video in all_videos:
            if video['id'] not in unique_videos:
                unique_videos[video['id']] = video
        
        return list(unique_videos.values())
    
    except Exception as e:
        st.error(f"Erro ao buscar tend√™ncias: {str(e)}")
        return []

def process_video_results(response):
    """Processar resultados da API e obter detalhes completos"""
    video_ids = [item['id']['videoId'] for item in response['items']]
    
    if not video_ids:
        return []
    
    # Buscar detalhes dos v√≠deos
    stats_request = youtube.videos().list(
        part='statistics,contentDetails',
        id=','.join(video_ids)
    )
    stats_response = stats_request.execute()
    
    # Combinar dados
    videos = []
    for i, item in enumerate(response['items']):
        video_stats = next((v for v in stats_response['items'] if v['id'] == item['id']['videoId']), None)
        
        if video_stats:
            channel_age_days = get_channel_age_days(item['snippet']['channelId'])
            
            video_data = {
                'id': item['id']['videoId'],
                'title': item['snippet']['title'],
                'channel_title': item['snippet']['channelTitle'],
                'channel_id': item['snippet']['channelId'],
                'published_at': item['snippet']['publishedAt'],
                'thumbnail': item['snippet']['thumbnails']['high']['url'],
                'description': item['snippet']['description'][:300] + '...' if len(item['snippet']['description']) > 300 else item['snippet']['description'],
                'views': int(video_stats['statistics'].get('viewCount', 0)),
                'likes': int(video_stats['statistics'].get('likeCount', 0)),
                'comments': int(video_stats['statistics'].get('commentCount', 0)),
                'duration_seconds': parse_duration(video_stats['contentDetails']['duration']),
                'url': f"https://www.youtube.com/watch?v={item['id']['videoId']}",
                'channel_url': f"https://www.youtube.com/channel/{item['snippet']['channelId']}",
                'channel_age_days': channel_age_days
            }
            
            # Calcular engagement rate
            if video_data['views'] > 0:
                video_data['engagement_rate'] = ((video_data['likes'] + video_data['comments']) / video_data['views']) * 100
            else:
                video_data['engagement_rate'] = 0
            
            videos.append(video_data)
    
    return videos

def filter_videos(videos, filters):
    """Aplicar filtros aos v√≠deos"""
    filtered = videos.copy()
    
    # Filtro por visualiza√ß√µes
    filtered = [v for v in filtered if filters['min_views'] <= v['views'] <= filters['max_views']]
    
    # Filtro por dura√ß√£o
    if filters['min_duration'] > 0 or filters['max_duration'] < 7200:
        filtered = [v for v in filtered if filters['min_duration'] <= v['duration_seconds'] <= filters['max_duration']]
    
    # Filtro por idade do canal
    if filters['max_channel_age_days'] < 9999:
        filtered = [v for v in filtered if v['channel_age_days'] <= filters['max_channel_age_days']]
    
    # Filtro por data de publica√ß√£o do v√≠deo
    if filters['video_max_age_days'] < 9999:
        cutoff_date = datetime.now() - timedelta(days=filters['video_max_age_days'])
        filtered = [v for v in filtered if datetime.fromisoformat(v['published_at'].replace('Z', '+00:00')).replace(tzinfo=None) >= cutoff_date]
    
    return filtered

def sort_videos(videos, sort_by):
    """Ordenar v√≠deos"""
    if sort_by == 'Mais recentes':
        return sorted(videos, key=lambda x: x['published_at'], reverse=True)
    elif sort_by == 'Mais antigos':
        return sorted(videos, key=lambda x: x['published_at'])
    elif sort_by == 'Mais visualiza√ß√µes':
        return sorted(videos, key=lambda x: x['views'], reverse=True)
    elif sort_by == 'Menos visualiza√ß√µes':
        return sorted(videos, key=lambda x: x['views'])
    elif sort_by == 'Mais likes':
        return sorted(videos, key=lambda x: x['likes'], reverse=True)
    elif sort_by == 'Maior engagement':
        return sorted(videos, key=lambda x: x['engagement_rate'], reverse=True)
    elif sort_by == 'Canais mais novos':
        return sorted(videos, key=lambda x: x['channel_age_days'])
    elif sort_by == 'Dura√ß√£o (menor)':
        return sorted(videos, key=lambda x: x['duration_seconds'])
    elif sort_by == 'Dura√ß√£o (maior)':
        return sorted(videos, key=lambda x: x['duration_seconds'], reverse=True)
    else:
        return videos

def is_trending_video(video, min_views_for_trending=10000):
    """Verificar se √© um v√≠deo em tend√™ncia"""
    days_old = (datetime.now() - datetime.fromisoformat(video['published_at'].replace('Z', '+00:00')).replace(tzinfo=None)).days
    if days_old <= 7 and video['views'] >= min_views_for_trending:
        return True
    return False

def is_new_channel(video, max_age_days=365):
    """Verificar se √© canal novo"""
    return video['channel_age_days'] <= max_age_days

def display_video_card(video, show_badges=True):
    """Exibir card do v√≠deo"""
    col1, col2 = st.columns([1, 2.5])
    
    with col1:
        try:
            response = requests.get(video['thumbnail'])
            img = Image.open(BytesIO(response.content))
            st.image(img, width=200)
        except:
            st.image("https://via.placeholder.com/320x180?text=No+Thumbnail", width=200)
        
        st.markdown(f"**‚è±Ô∏è {format_duration(video['duration_seconds'])}**")
    
    with col2:
        badges_html = ""
        if show_badges:
            if is_trending_video(video):
                badges_html += '<span class="trending-badge">üî• TRENDING</span>'
            if is_new_channel(video):
                badges_html += '<span class="new-channel-badge">‚ú® CANAL NOVO</span>'
        
        published_date = datetime.fromisoformat(video['published_at'].replace('Z', '+00:00')).strftime('%d/%m/%Y')
        days_old = (datetime.now() - datetime.fromisoformat(video['published_at'].replace('Z', '+00:00')).replace(tzinfo=None)).days
        
        st.markdown(f"""
        <div class="video-card">
            <div class="video-title">{video['title']} {badges_html}</div>
            <div class="channel-info">
                üì∫ <strong>{video['channel_title']}</strong> 
                <span style="color: #999;">‚Ä¢ Canal criado h√° {video['channel_age_days']} dias</span>
            </div>
            <div class="video-stats">
                üëÅÔ∏è {format_number(video['views'])} views ‚Ä¢ 
                üëç {format_number(video['likes'])} likes ‚Ä¢ 
                üí¨ {format_number(video['comments'])} coment√°rios ‚Ä¢ 
                üìà {video['engagement_rate']:.2f}% engagement
            </div>
            <div style="color: #666; font-size: 0.85rem; margin: 8px 0;">
                üìÖ Publicado em {published_date} ({days_old} dias atr√°s)
            </div>
            <p style="color: #666; font-size: 0.85rem; margin-top: 8px;">
                {video['description']}
            </p>
            <div style="margin-top: 10px;">
                <a href="{video['url']}" target="_blank" style="color: #FF0000; text-decoration: none; margin-right: 15px;">
                    üé• Assistir V√≠deo
                </a>
                <a href="{video['channel_url']}" target="_blank" style="color: #0066cc; text-decoration: none;">
                    üì∫ Ver Canal
                </a>
            </div>
        </div>
        """, unsafe_allow_html=True)

def display_metrics(videos):
    """Exibir m√©tricas dos resultados"""
    if not videos:
        return
    
    trending_count = sum(1 for v in videos if is_trending_video(v))
    new_channels_count = sum(1 for v in videos if is_new_channel(v))
    avg_engagement = sum(v['engagement_rate'] for v in videos) / len(videos)
    
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.markdown(f"""
        <div class="metric-container">
            <h3 style="margin: 0; color: #333;">üìä {len(videos)}</h3>
            <p style="margin: 0; color: #666;">V√≠deos Encontrados</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div class="metric-container">
            <h3 style="margin: 0; color: #FF6B6B;">üî• {trending_count}</h3>
            <p style="margin: 0; color: #666;">Em Tend√™ncia</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div class="metric-container">
            <h3 style="margin: 0; color: #4ECDC4;">‚ú® {new_channels_count}</h3>
            <p style="margin: 0; color: #666;">Canais Novos</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
        <div class="metric-container">
            <h3 style="margin: 0; color: #45B7D1;">üìà {avg_engagement:.1f}%</h3>
            <p style="margin: 0; color: #666;">Engagement M√©dio</p>
        </div>
        """, unsafe_allow_html=True)

# Interface principal
st.markdown('<h1 class="main-header">üöÄ YouTube Explorer Pro</h1>', unsafe_allow_html=True)

# Criar abas
tab1, tab2 = st.tabs(["üîç Busca Personalizada", "üî• Descobrir Tend√™ncias"])

# ABA 1: Busca Personalizada
with tab1:
    st.markdown('<h2 class="tab-header">üîç Busca com Filtros Personalizados</h2>', unsafe_allow_html=True)
    
    # Sidebar para aba 1
    with st.sidebar:
        st.markdown("## üéØ Filtros de Busca")
        
        # Busca b√°sica
        search_query = st.text_input("üîé Buscar por:", placeholder="Ex: react, receitas, investimentos...")
        
        # Filtros de v√≠deo
        st.markdown("### üé¨ Filtros de V√≠deo")
        
        col1, col2 = st.columns(2)
        with col1:
            min_views = st.number_input("Views m√≠n", min_value=0, value=1000, step=1000)
        with col2:
            max_views = st.number_input("Views m√°x", min_value=0, value=10000000, step=10000)
        
        # Idade do v√≠deo
        video_max_age = st.selectbox(
            "üìÖ V√≠deos publicados h√° no m√°ximo:",
            [1, 3, 7, 15, 30, 90, 365, 9999],
            format_func=lambda x: f"{x} dias" if x < 9999 else "Qualquer idade",
            index=2
        )
        
        # Dura√ß√£o do v√≠deo
        duration_range = st.select_slider(
            "‚è±Ô∏è Dura√ß√£o:",
            options=["Qualquer", "Curto (< 4min)", "M√©dio (4-20min)", "Longo (> 20min)"],
            value="Qualquer"
        )
        
        # Converter dura√ß√£o
        if duration_range == "Curto (< 4min)":
            min_duration, max_duration = 0, 240
        elif duration_range == "M√©dio (4-20min)":
            min_duration, max_duration = 240, 1200
        elif duration_range == "Longo (> 20min)":
            min_duration, max_duration = 1200, 7200
        else:
            min_duration, max_duration = 0, 7200
        
        # Filtros de canal
        st.markdown("### üÜï Filtros de Canal")
        channel_age = st.selectbox(
            "üì∫ Canais criados h√° no m√°ximo:",
            [30, 90, 180, 365, 730, 9999],
            format_func=lambda x: f"{x} dias" if x < 9999 else "Qualquer idade",
            index=3
        )
        
        # Ordena√ß√£o
        st.markdown("### üìä Ordena√ß√£o")
        sort_by = st.selectbox(
            "Ordenar por:",
            ['Mais recentes', 'Mais visualiza√ß√µes', 'Maior engagement', 'Canais mais novos', 'Mais likes', 'Dura√ß√£o (menor)', 'Dura√ß√£o (maior)']
        )
        
        # Quantidade de resultados
        max_results = st.selectbox("M√°ximo de resultados:", [10, 25, 50], index=1)
        
        # Bot√£o de busca
        search_button = st.button("üöÄ BUSCAR V√çDEOS", type="primary")
    
    # √Årea principal da aba 1
    if search_button and search_query:
        with st.spinner('üîç Buscando v√≠deos...'):
            published_after = datetime.now() - timedelta(days=video_max_age) if video_max_age < 9999 else None
            
            raw_videos = search_videos(
                search_query, 
                max_results=max_results, 
                published_after=published_after,
                order='date' if sort_by == 'Mais recentes' else 'relevance'
            )
            
            if raw_videos:
                filters = {
                    'min_views': min_views,
                    'max_views': max_views,
                    'min_duration': min_duration,
                    'max_duration': max_duration,
                    'max_channel_age_days': channel_age,
                    'video_max_age_days': video_max_age
                }
                
                filtered_videos = filter_videos(raw_videos, filters)
                
                if filtered_videos:
                    sorted_videos = sort_videos(filtered_videos, sort_by)
                    
                    # M√©tricas
                    display_metrics(sorted_videos)
                    
                    # Export
                    if st.button("üì• Exportar Resultados"):
                        df = pd.DataFrame(sorted_videos)
                        csv = df.to_csv(index=False)
                        st.download_button(
                            label="‚¨áÔ∏è Download CSV",
                            data=csv,
                            file_name=f"videos_busca_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                            mime="text/csv"
                        )
                    
                    # Resultados
                    st.markdown("---")
                    for video in sorted_videos:
                        display_video_card(video)
                        st.markdown("---")
                        
                else:
                    st.warning("‚ùå Nenhum v√≠deo encontrado com esses filtros.")
            else:
                st.error("‚ùå Nenhum v√≠deo encontrado.")
    
    elif search_button and not search_query:
        st.warning("‚ö†Ô∏è Digite algo para buscar!")
    
    else:
        st.markdown("""
        ## üéØ Busca Personalizada
        
        Configure seus filtros na barra lateral e digite um termo para buscar v√≠deos espec√≠ficos com crit√©rios avan√ßados.
        
        **Exemplos de busca:**
        - "investimentos" + canais novos + √∫ltima semana
        - "receitas" + v√≠deos curtos + alta visualiza√ß√£o
        - "tecnologia" + canais recentes + maior engagement
        """)

# ABA 2: Descobrir Tend√™ncias
with tab2:
    st.markdown('<h2 class="tab-header">üî• Descobrir o que est√° Bombando Agora</h2>', unsafe_allow_html=True)
    
    # Controles simples para tend√™ncias
    st.markdown("""
    <div class="trending-section">
        <h3 style="margin-top: 0;">üéØ Sem busca, sem complica√ß√£o!</h3>
        <p>Encontre automaticamente os v√≠deos que est√£o bombando nos √∫ltimos dias. 
        Configure apenas as views m√≠nimas e veja as tend√™ncias emergirem!</p>
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        trending_min_views = st.selectbox(
            "üëÅÔ∏è Views m√≠nimas:",
            [500, 1000, 2000, 5000, 10000, 20000, 50000],
            index=2,  # 2000 por padr√£o
            help="V√≠deos devem ter pelo menos essa quantidade de visualiza√ß√µes"
        )
    
    with col2:
        trending_days = st.selectbox(
            "üìÖ √öltimos:",
            [1, 3, 7, 15],
            index=2,  # 7 dias por padr√£o
            format_func=lambda x: f"{x} dias"
        )
    
    with col3:
        trending_sort = st.selectbox(
            "üìä Ordenar por:",
            ['Mais recentes', 'Mais visualiza√ß√µes', 'Maior engagement'],
            index=0  # Mais recentes por padr√£o
        )
    
    with col4:
        trending_results = st.selectbox(
            "üìà Quantidade:",
            [20, 30, 50],
            index=1  # 30 por padr√£o
        )
    
    # Bot√£o para descobrir tend√™ncias
    if st.button("üöÄ DESCOBRIR TEND√äNCIAS AGORA!", type="primary", use_container_width=True):
        with st.spinner(f'üî• Descobrindo v√≠deos em alta dos √∫ltimos {trending_days} dias...'):
            trending_videos = get_trending_videos(
                min_views=trending_min_views,
                days_back=trending_days,
                max_results=trending_results
            )
            
            if trending_videos:
                # Ordenar conforme sele√ß√£o
                sorted_trending = sort_videos(trending_videos, trending_sort)
                
                # M√©tricas
                display_metrics(sorted_trending)
                
                # Export
                if st.button("üì• Exportar Tend√™ncias"):
                    df = pd.DataFrame(sorted_trending)
                    csv = df.to_csv(index=False)
                    st.download_button(
                        label="‚¨áÔ∏è Download CSV Tend√™ncias",
                        data=csv,
                        file_name=f"tendencias_youtube_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv"
                    )
                
                # Resultados
                st.markdown("---")
                st.markdown("## üî• V√≠deos em Tend√™ncia:")
                
                for video in sorted_trending:
                    display_video_card(video)
                    st.markdown("---")
                    
            else:
                st.warning("‚ùå Nenhuma tend√™ncia encontrada com esses crit√©rios. Tente views m√≠nimas menores.")
    
    else:
        # Tela inicial da aba tend√™ncias
        st.markdown("""
        ## üöÄ Como funciona:
        
        1. **Escolha as views m√≠nimas** - quantas visualiza√ß√µes um v√≠deo deve ter para ser considerado "em alta"
        2. **Selecione o per√≠odo** - √∫ltimos 1, 3, 7 ou 15 dias
        3. **Escolha a ordena√ß√£o** - mais recentes, mais views ou maior engagement
        4. **Clique em "DESCOBRIR"** - e pronto! Veja o que est√° bombando sem digitar nada
        
        ### üéØ Perfeito para:
        - ‚úÖ **Descobrir nichos emergentes** sem saber por onde come√ßar
        - ‚úÖ **Ver o que est√° viral AGORA** nos √∫ltimos dias
        - ‚úÖ **Encontrar oportunidades** de conte√∫do em alta
        - ‚úÖ **Monitorar tend√™ncias gerais** do YouTube Brasil
        
        **üëÜ Configure as op√ß√µes acima e descubra as tend√™ncias!**
        """)

# Rodap√©
st.markdown("---")
st.markdown("""
<div style="text-align: center; color: #666; padding: 20px;">
    <p>üöÄ <strong>YouTube Explorer Pro</strong> | Encontre v√≠deos em alta de canais novos</p>
    <p>Desenvolvido para descobrir tend√™ncias emergentes antes da concorr√™ncia!</p>
</div>
""", unsafe_allow_html=True)
